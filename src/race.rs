use super::*;

/// A result of racing two routines
///
/// This is generated by race, and allows you to
/// continue with the 'losing' coroutine, and
/// examing the result of the 'winning' courtine
pub enum RaceResult<'a, I, O, A, B> {
    Left {
        value: A,
        remaining: Coroutine<'a, I, O, B>,
    },
    Right {
        value: B,
        remaining: Coroutine<'a, I, O, A>,
    },
}

/// Run both coroutines, and returns which finishes first
/// For each step this feeds inputs to left first, then right
/// so if they are equal, left will return first
/// Raceresult returns the value, and the remaining coroutine, so it
/// can be ran elsewhere
///
/// Input must be clone-able, as it needs to be consumed by both routines
pub fn race<'a, I, O, A, B>(
    a: Coroutine<'a, I, O, A>,
    b: Coroutine<'a, I, O, B>,
) -> Coroutine<'a, I, O, RaceResult<'a, I, O, A, B>>
where
    I: Clone,
{
    let sr1 = run_step(a);
    let sr2 = run_step(b);
    match (sr1, sr2) {
        (StepResult::Done(value), StepResult::Done(b)) => {
            let ret = RaceResult::Left {
                value,
                remaining: result(b),
            };
            result(ret)
        }
        (StepResult::Done(value), StepResult::Yield { output, next }) => {
            let remaining = *next;
            let race = RaceResult::Left { value, remaining };
            right(send(output), result(race))
        }
        (StepResult::Done(value), StepResult::Next(next)) => {
            let remaining = suspend(next);
            result(RaceResult::Left { value, remaining })
        }
        (StepResult::Yield { output, next }, StepResult::Done(value)) => {
            let remaining = *next;
            let race = RaceResult::Right { value, remaining };
            right(send(output), result(race))
        }
        (
            StepResult::Yield {
                output: a,
                next: na,
            },
            StepResult::Yield {
                output: b,
                next: nb,
            },
        ) => {
            let send = tuple(send(a), send(b));
            let next = race(*na, *nb);
            right(send, next)
        }
        (StepResult::Yield { output, next: a }, StepResult::Next(b)) => {
            let send = send(output);
            let next = race(*a, suspend(b));
            right(send, next)
        }
        (StepResult::Next(a), StepResult::Done(value)) => {
            let remaining = suspend(a);
            let race = RaceResult::Right { value, remaining };
            result(race)
        }
        (StepResult::Next(a), StepResult::Yield { output, next }) => {
            let send = send(output);
            let a = suspend(a);
            let b = *next;
            let next = race(a, b);
            right(send, next)
        }
        (StepResult::Next(a), StepResult::Next(b)) => {
            let on_input = |input: I| {
                let a = a(input.clone());
                let b = b(input);
                race(a, b)
            };
            bind(receive(), on_input)
        }
    }
}

/// Sends inputs to both coroutines, and will emit outputs together
/// If one finishes first, the other will consume the inputs until it is finished.
/// Both routines must finish to return
/// Input must be copyable, as it will need to feed both
pub fn broadcast<'a, I, O, A, B>(
    first: Coroutine<'a, I, O, A>,
    second: Coroutine<'a, I, O, B>,
) -> Coroutine<'a, I, O, (A, B)>
where
    I: Clone,
{
    let rr = race(first, second);
    let on_result = |res| match res {
        RaceResult::Left { value, remaining } => map(remaining, |b| (value, b)),
        RaceResult::Right { value, remaining } => map(remaining, |a| (a, value)),
    };
    bind(rr, on_result)
}
